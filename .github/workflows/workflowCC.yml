name: Generar funcionalidad desde historia de usuario

on:
  push:
    paths:
      - 'historias-usuario/**.yml'

jobs:
  generar_codigo:
    runs-on: ubuntu-latest

    steps:
      - name: Clonar repositorio actual
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          path: repositorio-base

      - name: Detectar historia de usuario modificada
        id: historia
        run: |
          cd repositorio-base
          git fetch --unshallow || true
          base_sha="${{ github.event.before }}"
          if ! git cat-file -e "$base_sha"^{commit} 2>/dev/null; then
            echo "‚ö†Ô∏è SHA base no v√°lido o sin historial, usando HEAD^"
            base_sha="HEAD^"
          fi
          echo "üîç Comparando con base: $base_sha"
          archivo=$(git diff --name-only "$base_sha" HEAD | grep '^historias-usuario/.*\.yml$' | head -n 1 || true)
          if [ -z "$archivo" ]; then
            echo "‚õî No se encontr√≥ ninguna historia de usuario modificada. Abortando."
            exit 1
          fi
          echo "ruta=$archivo" >> "$GITHUB_OUTPUT"

      - name: Leer contenido de historia de usuario
        run: |
          cd repositorio-base
          cat "${{ steps.historia.outputs.ruta }}" > entrada_gpt.txt

      - name: Instalar dependencias necesarias
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip openjdk-17-jdk maven

      - name: Indexar y agregar contenido de clases Java existentes al prompt
        run: |
          cd repositorio-base

          echo "üìÅ Buscando clases Java..."
          find src/main/java -type f -name "*.java" > clases_existentes.txt

          if [ ! -s clases_existentes.txt ]; then
            echo "‚ùå No se encontraron archivos .java. Abortando."
            exit 1
          fi

          echo -e "\n\n--- HISTORIA DE USUARIO ---" > entrada_gpt.txt
          cat "${{ steps.historia.outputs.ruta }}" >> entrada_gpt.txt

          echo -e "\n\n--- C√ìDIGO EXISTENTE DEL PROYECTO ---" >> entrada_gpt.txt

          while read -r clase; do
            echo -e "\n\n// Archivo: $clase\n" >> entrada_gpt.txt
            cat "$clase" >> entrada_gpt.txt
          done < clases_existentes.txt

          cat <<'EOF' >> entrada_gpt.txt

          --- AN√ÅLISIS DE CLASES EXISTENTES ---
          Genera una tabla Markdown como esta:

          | Clase Java | Clasificaci√≥n | Motivo |
          |------------|----------------|--------|
          | Employee | REUTILIZABLE-AS-IS | Contiene atributo `gender` |
          | EmployeeServiceImpl | MODIFICABLE | Debe validar antes de borrar |
          | NuevaClaseX | NUEVA | Requerida por funcionalidad nueva |

          --- INSTRUCCIONES DE MODIFICACI√ìN ---
          - No eliminar ni reemplazar l√≥gica existente.
          - Si se modifica un m√©todo, incluirlo completo con el nuevo c√≥digo y lo que ya ten√≠a.
          - Solo generar clases nuevas si est√°n indicadas como NUEVA.
          - NO repetir clases ya existentes si no cambian.

          --- C√ìDIGO A GENERAR ---
          Devuelve solo clases Java v√°lidas. Cada bloque debe comenzar con `package ...`.
          Tambi√©n incluye tests JUnit5 si aplica.
          EOF

      - name: Mostrar tabla de diagn√≥stico (si existe)
        run: |
          echo "üìã Tabla de clases seg√∫n GPT:"
          grep '|' repositorio-base/respuesta_gpt.json || echo "‚ö†Ô∏è GPT no gener√≥ tabla de diagn√≥stico"

      - name: Llamar a OpenAI para diagn√≥stico (solo an√°lisis y clasificaci√≥n)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          cd repositorio-base

          jq -Rs --arg SYSTEM_MSG "Eres un analizador experto de c√≥digo Java. Devuelve solo el an√°lisis de clases existentes y el plan de modificaci√≥n. No devuelvas c√≥digo a√∫n." '{
            model: "gpt-4",
            messages: [
              { "role": "system", "content": $SYSTEM_MSG },
              { "role": "user", "content": . }
            ],
            temperature: 0.2
          }' entrada_gpt.txt > payload_diagnostico.json

          curl -s https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_diagnostico.json > respuesta_gpt_diagnostico.json

          echo "üì® Respuesta de OpenAI:"
          cat respuesta_gpt_diagnostico.json

          jq -r '.choices[0].message.content // "‚ùå GPT no devolvi√≥ contenido v√°lido."' respuesta_gpt_diagnostico.json > diagnostico_gpt.txt

      - name: Mostrar an√°lisis GPT
        run: |
          echo "üìã Tabla de diagn√≥stico de clases:"
          cat repositorio-base/diagnostico_gpt.txt || echo "‚ö†Ô∏è No se pudo leer diagn√≥stico"

      - name: Preparar entrada para generaci√≥n de c√≥digo
        run: |
          cd repositorio-base

          echo "--- HISTORIA DE USUARIO ---" > entrada_final_gpt.txt
          cat "${{ steps.historia.outputs.ruta }}" >> entrada_final_gpt.txt

          echo -e "\n\n--- DIAGN√ìSTICO Y PLAN DE CLASES ---" >> entrada_final_gpt.txt
          cat diagnostico_gpt.txt >> entrada_final_gpt.txt

          cat <<'EOF' >> entrada_final_gpt.txt

          --- INSTRUCCIONES DE GENERACI√ìN DE C√ìDIGO ---
          - Modifica √∫nicamente las clases marcadas como MODIFICABLE.
          - Crea nuevas clases solo si est√°n indicadas como NUEVA.
          - No cambies de paquete ni nombre de clase.
          - Si modificas un m√©todo, incl√∫yelo completo con su l√≥gica anterior m√°s la nueva.
          - No omitas l√≥gica existente.
          - Cada clase debe comenzar con `package ...`.
          - Devuelve √∫nicamente clases y tests JUnit 5 v√°lidos.
          - No incluyas explicaciones ni comentarios adicionales.

          EOF


      - name: Llamar a OpenAI para generaci√≥n de c√≥digo
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          cd repositorio-base

          # Guardamos el contenido del prompt como variable segura
          PROMPT=$(cat entrada_final_gpt.txt | jq -Rs .)

          # Creamos el JSON de payload
          cat <<EOF > payload_generacion.json
          {
            "model": "gpt-4",
            "messages": [
              {
                "role": "system",
                "content": "Eres un generador de c√≥digo Java experto en Spring Boot. Cada clase que modifiques debe incluir todos sus m√©todos existentes reales, no los resumas ni los reemplaces por comentarios. NO USES '// Other methods...' NI NING√öN COMENTARIO QUE OMITE M√âTODOS. Si modificas una clase, incluye su c√≥digo completo, con todos los m√©todos existentes intactos m√°s los nuevos o modificados. No inventes clases nuevas salvo que est√©n marcadas como NUEVA en el an√°lisis. No incluyas texto fuera del c√≥digo. Cada clase debe comenzar con 'package ...'."
              },
              {
                "role": "user",
                "content": $PROMPT
              }
            ],
            "temperature": 0.3
          }
          EOF

          echo "üßæ Payload generado para OpenAI:"
          cat payload_generacion.json

          curl -s https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_generacion.json > respuesta_gpt.json

          echo "üì® Respuesta de OpenAI:"
          cat respuesta_gpt.json

          jq -r '.choices[0].message.content // "‚ùå GPT no devolvi√≥ contenido v√°lido."' respuesta_gpt.json > clases_generadas.java

      - name: Separar clases generadas
        run: |
          cd repositorio-base
          mkdir -p src/main/java/ai/generated
          mkdir -p src/test/java/ai/generated
          csplit --quiet --prefix=clase_ --suffix-format=%02d.java clases_generadas.java "/^package /" {*}
          mkdir -p src/main/java/ai/generated src/test/java/ai/generated
          i=1

          for file in clase_*.java; do
            # Validar que el archivo comienza con 'package' y contiene 'class', 'interface' o 'enum'
            if ! grep -qE '^\s*package\s+[a-zA-Z0-9_.]+;' "$file"; then
              echo "‚ö†Ô∏è Archivo $file no contiene declaraci√≥n de paquete v√°lida. Eliminando."
              rm "$file"
              continue
            fi

            if ! grep -qE '\b(class|interface|enum)\b' "$file"; then
              echo "‚ö†Ô∏è Archivo $file no contiene clase, interfaz ni enum. Eliminando."
              rm "$file"
              continue
            fi

            # Obtener nombre de clase
            class_name=$(grep -oP 'public\s+(class|interface|enum)\s+\K\w+' "$file" | head -n 1)

            # Clasificar como test o clase principal
            if grep -q '@Test' "$file"; then
              dest="src/test/java/ai/generated"
            else
              dest="src/main/java/ai/generated"
            fi

            mv "$file" "$dest/${class_name:-ClaseGenerada_$i}.java"
            i=$((i+1))
          done


      - name: Ejecutar pruebas unitarias (incluye regresi√≥n)
        run: |
          cd repositorio-base
          mvn test || echo "‚ö†Ô∏è Algunos tests fallaron, revisar logs"

      - name: Commit y push de la nueva funcionalidad
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          cd repositorio-base
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git checkout -b feature/autogenerado-${{ github.run_id }}
          git add .
          if git diff --cached --quiet; then
            echo "‚õî No hay cambios para commitear, se omite push"
            exit 0
          fi
          git commit -m "ü§ñ Funcionalidad generada desde historia de usuario"
          git remote set-url origin https://x-access-token:${GH_PAT}@github.com/${{ github.repository }}.git
          git push origin HEAD
