name: Generar funcionalidad desde historia de usuario

on:
  push:
    paths:
      - 'historias-usuario/**.yml'

jobs:
  generar_codigo:
    runs-on: ubuntu-latest

    steps:
      - name: Clonar repositorio actual
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          path: repositorio-base

      - name: Detectar historia de usuario modificada
        id: historia
        run: |
          cd repositorio-base
          git fetch --unshallow || true

          base_sha="${{ github.event.before }}"
          if ! git cat-file -e "$base_sha"^{commit} 2>/dev/null; then
            echo "‚ö†Ô∏è SHA base no v√°lido o sin historial, usando HEAD^"
            base_sha="HEAD^"
          fi

          echo "üîç Comparando con base: $base_sha"
          archivo=$(git diff --name-only "$base_sha" HEAD | grep '^historias-usuario/.*\.yml$' | head -n 1 || true)

          if [ -z "$archivo" ]; then
            echo "‚õî No se encontr√≥ ninguna historia de usuario modificada. Abortando."
            exit 1
          fi

          echo "üìù Historia modificada: $archivo"
          echo "ruta=$archivo" >> "$GITHUB_OUTPUT"

      - name: Leer contenido de historia de usuario
        run: |
          cd repositorio-base
          cat "${{ steps.historia.outputs.ruta }}" > entrada_gpt.txt

      - name: Instalar dependencias necesarias
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip openjdk-17-jdk maven

      - name: Indexar clases Java existentes y preparar prompt
        run: |
          echo "üìÅ Buscando clases Java dentro de repositorio-base/src/main/java..."
          find repositorio-base/src/main/java -type f -name "*.java" > clases_existentes.txt

          if [ ! -s clases_existentes.txt ]; then
            echo "‚ùå No se encontraron archivos .java. Abortando."
            exit 1
          fi

          echo "Historia de usuario recibida:" > entrada_gpt.txt
          cat repositorio-base/${{ steps.historia.outputs.ruta }} >> entrada_gpt.txt

          echo -e "\nResumen de clases existentes (nombre + contenido relevante):" >> entrada_gpt.txt
          while read -r clase; do
            echo -e "\n--- ${clase} ---" >> entrada_gpt.txt
            echo "package $(grep '^package' "$clase")" >> entrada_gpt.txt
            grep -E 'public (class|interface|enum)|@Entity|@Table|private|protected|public' "$clase" | head -n 50 >> entrada_gpt.txt
          done < clases_existentes.txt


          cat <<'EOF' >> entrada_gpt.txt

          --- AN√ÅLISIS (Fase 1) ---
          Analiza las clases detectadas. Indica:
          1. Qu√© clases pueden reutilizarse sin modificar.
          2. Qu√© clases deben ser modificadas (a√±adir m√©todos, anotaciones, etc.).
          3. Qu√© clases deben ser nuevas.

          --- DISE√ëO (Fase 2) ---
          Para las clases a modificar:
          - Explica brevemente qu√© se agrega y por qu√©.
          - No elimines atributos ni sobrescribas l√≥gica existente.

          --- GENERACI√ìN (Fase 3) ---
          Genera √∫nicamente las clases nuevas o modificadas.
          Cada clase debe comenzar con 'package ...'.
          No incluyas explicaciones ni comentarios.
          EOF

          echo "üß† Contenido final del prompt:"
          cat entrada_gpt.txt

      - name: An√°lisis previo de clases (diagn√≥stico)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          cd repositorio-base
          PROMPT=$(cat entrada_gpt.txt)
          jq -n --arg prompt "$PROMPT" ' {
            model: "gpt-4",
            messages: [
              {
                "role": "system",
                "content": "Eres un arquitecto de software. Clasifica las clases Java existentes como: reutilizables, modificables o nuevas seg√∫n la historia de usuario. Solo devuelve una tabla en Markdown."
              },
              { "role": "user", "content": $prompt }
            ],
            temperature: 0.2
          }' > payload_diagnostico.json

          curl -s https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_diagnostico.json > diagnostico.json

          echo "üìã Diagn√≥stico de clases:"
          jq -r '.choices[0].message.content // "‚ùå No se encontr√≥ diagn√≥stico v√°lido."' diagnostico.json

      - name: Llamar a OpenAI para generar clases y tests
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          cd repositorio-base
          PROMPT=$(cat entrada_gpt.txt)
          jq -n --arg prompt "$PROMPT" ' {
            model: "gpt-4",
            messages: [
              { "role": "system", "content": "Eres un generador de c√≥digo Java experto en Spring Boot. Solo devuelve clases y tests JUnit v√°lidos, separados por l√≠neas que comiencen con 'package'. No incluyas texto adicional." },
              { "role": "user", "content": $prompt }
            ],
            temperature: 0.3
          }' > payload.json

          curl -s https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload.json > respuesta_gpt.json

          jq -r '.choices[0].message.content // "‚ùå No se encontr√≥ contenido v√°lido en la respuesta de GPT."' respuesta_gpt.json > clases_generadas.java

      - name: Separar clases generadas
        run: |
          mkdir -p repositorio-base/src/main/java/ai/generated
          mkdir -p repositorio-base/src/test/java/ai/generated
          cd repositorio-base
          csplit --quiet --prefix=clase_ --suffix-format=%02d.java clases_generadas.java "/^package /" {*}
          i=1
          for file in clase_*.java; do
            class_name=$(grep -oP 'public\s+(class|interface|enum)\s+\K\w+' "$file" | head -n 1)
            if grep -q '@Test' "$file"; then
              dest="src/test/java/ai/generated"
            else
              dest="src/main/java/ai/generated"
            fi
            if [ -n "$class_name" ]; then
              mv "$file" "$dest/${class_name}.java"
            else
              mv "$file" "$dest/ClaseGenerada_$i.java"
            fi
            i=$((i+1))
          done

      - name: Ejecutar pruebas unitarias
        run: |
          cd repositorio-base
          mvn test || echo "‚ö†Ô∏è Algunos tests fallaron, revisar en GitHub Actions log"

      - name: Commit y push a nueva rama
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          cd repositorio-base
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git checkout -b feature/autogenerado-${{ github.run_id }}

          git add .
          if git diff --cached --quiet; then
            echo "‚õî No hay cambios para commitear, se omite push"
            exit 0
          fi

          git commit -m "ü§ñ Funcionalidad generada desde historia de usuario"
          git remote set-url origin https://x-access-token:${GH_PAT}@github.com/${{ github.repository }}.git
          git push origin HEAD
