name: Generar funcionalidad desde historia de usuario

on:
  push:
    paths:
      - 'historias-usuario/**.yml'

jobs:
  generar_codigo:
    runs-on: ubuntu-latest

    steps:
      - name: Clonar repositorio actual
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          path: repositorio-base

      - name: Detectar historia de usuario modificada
        id: historia
        run: |
          cd repositorio-base
          git fetch --unshallow || true
          base_sha="${{ github.event.before }}"
          if ! git cat-file -e "$base_sha"^{commit} 2>/dev/null; then
            echo "‚ö†Ô∏è SHA base no v√°lido o sin historial, usando HEAD^"
            base_sha="HEAD^"
          fi
          echo "üîç Comparando con base: $base_sha"
          archivo=$(git diff --name-only "$base_sha" HEAD | grep '^historias-usuario/.*\.yml$' | head -n 1 || true)
          if [ -z "$archivo" ]; then
            echo "‚õî No se encontr√≥ ninguna historia de usuario modificada. Abortando."
            exit 1
          fi
          echo "ruta=$archivo" >> "$GITHUB_OUTPUT"

      - name: Leer contenido de historia de usuario
        run: |
          cd repositorio-base
          cat "${{ steps.historia.outputs.ruta }}" > entrada_gpt.txt

      - name: Instalar dependencias necesarias
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip openjdk-17-jdk maven

      - name: Indexar y agregar contenido de clases Java existentes al prompt
        run: |
          cd repositorio-base

          echo "üìÅ Buscando clases Java..."
          find src/main/java -type f -name "*.java" > clases_existentes.txt

          if [ ! -s clases_existentes.txt ]; then
            echo "‚ùå No se encontraron archivos .java. Abortando."
            exit 1
          fi

          echo -e "\n\n--- HISTORIA DE USUARIO ---" > entrada_gpt.txt
          cat "${{ steps.historia.outputs.ruta }}" >> entrada_gpt.txt

          echo -e "\n\n--- C√ìDIGO EXISTENTE DEL PROYECTO ---" >> entrada_gpt.txt

          while read -r clase; do
            echo -e "\n\n// Archivo: $clase\n" >> entrada_gpt.txt

            # Validaci√≥n fuerte: si el archivo contiene '// Other methods...', aborta
            if grep -q '// Other methods' "$clase"; then
              echo "‚õî El archivo $clase contiene '// Other methods...'. Reempl√°zalo por el c√≥digo real antes de continuar."
              exit 1
            fi

            cat "$clase" >> entrada_gpt.txt
          done < clases_existentes.txt

          cat <<'EOF' >> entrada_gpt.txt

          --- AN√ÅLISIS DE CLASES EXISTENTES ---
          Genera una tabla Markdown como esta:

          | Clase Java | Package | Clasificaci√≥n | Motivo |
          |------------|---------|----------------|--------|
          | Employee | com.example.EmployeeCoreApi.model | REUTILIZABLE-AS-IS | Contiene atributo `gender` |
          | EmployeeServiceImpl | com.example.EmployeeCoreApi.service.impl | MODIFICABLE | Debe validar antes de borrar |
          | CannotDeleteEmployeeException | com.example.EmployeeCoreApi.exception | NUEVA | Requerida para lanzar excepci√≥n |
          | EmployeeServiceImplTest | com.example.EmployeeCoreApi.service.impl | NUEVA | Pruebas unitarias de validaci√≥n |

          --- INSTRUCCIONES DE MODIFICACI√ìN ---
          - No eliminar ni reemplazar l√≥gica existente.
          - Si se modifica un m√©todo, incluirlo completo con el nuevo c√≥digo y lo que ya ten√≠a.
          - Solo generar clases nuevas si est√°n indicadas como NUEVA.
          - Cada clase debe estar en su package correcto, seg√∫n lo indicado en la tabla.
          - NO repetir clases ya existentes si no cambian.
          - NO eliminar los m√©todos existentes a menos que sea necesario
          - NO reemplazar m√©todos u otro contenido de las clases existentes por comentarios entre l√≠neas

          --- C√ìDIGO A GENERAR ---
          Devuelve solo clases Java v√°lidas. Cada bloque debe comenzar con `package ...`.
          Incluye los tests JUnit5 en el mismo formato si aplica.
          EOF


      - name: Mostrar tabla de diagn√≥stico (si existe)
        run: |
          echo "üìã Tabla de clases seg√∫n GPT:"
          grep '|' repositorio-base/respuesta_gpt.json || echo "‚ö†Ô∏è GPT no gener√≥ tabla de diagn√≥stico"

      - name: Llamar a OpenAI para diagn√≥stico (solo an√°lisis y clasificaci√≥n)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          cd repositorio-base

          jq -Rs --arg SYSTEM_MSG "Eres un analizador experto de c√≥digo Java. Devuelve solo el an√°lisis de clases existentes y el plan de modificaci√≥n. No devuelvas c√≥digo a√∫n." '{
            model: "gpt-4",
            messages: [
              { "role": "system", "content": $SYSTEM_MSG },
              { "role": "user", "content": . }
            ],
            temperature: 0.2
          }' entrada_gpt.txt > payload_diagnostico.json

          curl -s https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_diagnostico.json > respuesta_gpt_diagnostico.json

          echo "üì® Respuesta de OpenAI:"
          cat respuesta_gpt_diagnostico.json

          jq -r '.choices[0].message.content // "‚ùå GPT no devolvi√≥ contenido v√°lido."' respuesta_gpt_diagnostico.json > diagnostico_gpt.txt

      - name: Mostrar an√°lisis GPT
        run: |
          echo "üìã Tabla de diagn√≥stico de clases:"
          cat repositorio-base/diagnostico_gpt.txt || echo "‚ö†Ô∏è No se pudo leer diagn√≥stico"

      - name: Preparar entrada para generaci√≥n de c√≥digo
        run: |
          cd repositorio-base

          echo "--- HISTORIA DE USUARIO ---" > entrada_final_gpt.txt
          cat "${{ steps.historia.outputs.ruta }}" >> entrada_final_gpt.txt

          echo -e "\n\n--- DIAGN√ìSTICO Y PLAN DE CLASES ---" >> entrada_final_gpt.txt
          cat diagnostico_gpt.txt >> entrada_final_gpt.txt

          cat <<'EOF' >> entrada_final_gpt.txt

          --- INSTRUCCIONES DE GENERACI√ìN DE C√ìDIGO ---
          - Modifica √∫nicamente las clases marcadas como MODIFICABLE.
          - Crea nuevas clases solo si est√°n indicadas como NUEVA.
          - No cambies de paquete ni nombre de clase.
          - Si modificas un m√©todo, incl√∫yelo completo con su l√≥gica anterior m√°s la nueva.
          - No omitas l√≥gica existente.
          - Cada clase debe comenzar con `package ...`.
          - Devuelve √∫nicamente clases y tests JUnit 5 v√°lidos.
          - No incluyas explicaciones ni comentarios adicionales.
          - Si una clase existente implementa una interfaz, o hereda de otra clase, debes mantener esa declaraci√≥n `implements o extends ...`.
          - No elimines implementaciones de interfaces ya declaradas.
          - La firma de las clases y m√©todos debe mantenerse sin cambio a menos que la nueva funcionalidad lo requiera

          EOF


      - name: Llamar a OpenAI para generaci√≥n de c√≥digo
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          cd repositorio-base

          # Guardamos el contenido del prompt como variable segura
          PROMPT=$(cat entrada_final_gpt.txt | jq -Rs .)

          # Creamos el JSON de payload
          cat <<EOF > payload_generacion.json
          {
            "model": "gpt-4",
            "messages": [
              {
                "role": "system",
                "content": "Eres un generador de c√≥digo Java experto en Spring Boot. Tu salida debe contener √∫nicamente c√≥digo fuente Java completamente v√°lido. Cada clase debe comenzar con 'package ...' y contener la declaraci√≥n completa de la clase (public class, interface o enum). No debes escribir ning√∫n texto explicativo, encabezado, numeraci√≥n, ni comentarios como '1.', '2.', 'Test Unitario:', etc. Si la clase ya existe en el repositorio, debes conservar su package original y todos sus m√©todos, incluso si no se modifican. No puedes inventar nuevos packages como 'com.example.demo'. Si una clase es nueva, debe estar marcada como NUEVA en el an√°lisis previo. No escribas ning√∫n contenido fuera de los bloques de c√≥digo. El resultado debe ser compilable sin errores ni contenido basura."
              },
              {
                "role": "user",
                "content": $PROMPT
              }
            ],
            "temperature": 0.3
          }
          EOF

          echo "üßæ Payload generado para OpenAI:"
          cat payload_generacion.json

          curl -s https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_generacion.json > respuesta_gpt.json

          echo "üì® Respuesta de OpenAI:"
          cat respuesta_gpt.json

          jq -r '.choices[0].message.content // "‚ùå GPT no devolvi√≥ contenido v√°lido."' respuesta_gpt.json \
          | sed '/^```/d' \
          > clases_generadas.java

      - name: Limpiar y separar clases generadas
        run: |
          cd repositorio-base
      
          # === LIMPIEZA DE BLOQUE GPT ===
          echo "üßπ Limpiando residuos de formato GPT..."
          sed -i '/^---/d' clases_generadas.java
          sed -i '/^```/d' clases_generadas.java
          sed -i '/^\/\/ Clase de prueba:/d' clases_generadas.java
          sed -i '/^\/\/ Clase modificada:/d' clases_generadas.java
          sed -i '/^\/\/ Resto de los m√©todos existentes\.\.\./d' clases_generadas.java
          sed -i '/^# .*$/d' clases_generadas.java
          sed -i '/^--- CLASE MODIFICADA ---/d' clases_generadas.java
          sed -i '${/^$/d;}' clases_generadas.java
          # üîç Eliminar encabezados tipo markdown que confunden la separaci√≥n de clases
          sed -i '/^[0-9]\+\.\s\+Clase/d' clases_generadas.java
          sed -i '/^[0-9]\+\.\s\+Pruebas/d' clases_generadas.java
          sed -i '/^.*Clase.*nueva.*$/d' clases_generadas.java
          sed -i '/^.*Pruebas.*$/d' clases_generadas.java

      
          # === ELIMINAR L√çNEAS ANTES DEL PRIMER package ===
          sed -i '1,/^package /{/^package /!d}' clases_generadas.java
      
          # === SEPARACI√ìN DE CLASES ===
          echo "üìÇ Separando clases en archivos individuales..."
          mkdir -p src/main/java/ai/generated
          mkdir -p src/test/java/ai/generated
          csplit --quiet --prefix=clase_ --suffix-format=%02d.java clases_generadas.java "/^package /" {*}
      
          echo "üìÇ Procesando archivos clase_*.java..."

          i=1
          for file in clase_*.java; do
            echo "üîç Analizando archivo: $file"

            # Validar que el archivo contiene declaraci√≥n de paquete v√°lida
            if ! grep -qE '^\s*package\s+[a-zA-Z0-9_.]+;' "$file"; then
              echo "‚ö†Ô∏è Archivo $file no contiene declaraci√≥n de paquete v√°lida. Eliminando."
              rm "$file"
              continue
            fi

            # Validar que contiene una clase, interfaz o enum
            if ! grep -qE '\b(class|interface|enum)\b' "$file"; then
              echo "‚ö†Ô∏è Archivo $file no contiene clase, interfaz ni enum. Eliminando."
              rm "$file"
              continue
            fi

            # Obtener nombre de la clase, interfaz o enum
            class_name=$(grep -oP 'public\s+(class|interface|enum)\s+\K\w+' "$file" | head -n 1)

            # Validar que se haya encontrado un nombre de clase
            if [ -z "$class_name" ]; then
              echo "‚ö†Ô∏è No se pudo determinar el nombre de clase en $file. Eliminando."
              rm "$file"
              continue
            fi

            # Determinar si es test
            if grep -q '@Test' "$file"; then
              dest="src/test/java/ai/generated"
              echo "‚úÖ Clasificado como TEST -> $dest/${class_name}.java"
            else
              dest="src/main/java/ai/generated"
              echo "‚úÖ Clasificado como CLASE -> $dest/${class_name}.java"
            fi

            mv "$file" "$dest/${class_name}.java"
            i=$((i+1))
          done


      - name: Reemplazar clases generadas en ubicaci√≥n original
        run: |
          cd repositorio-base

          echo "üì¶ Detectando package y ubicaci√≥n de cada clase..."

          for file in src/main/java/ai/generated/*.java src/test/java/ai/generated/*.java; do
            [ -e "$file" ] || continue

            package_line=$(grep '^package ' "$file" | head -n 1)
            package_path=$(echo "$package_line" | sed -E 's/package ([a-zA-Z0-9_.]+);/\1/' | tr '.' '/')
            class_name=$(basename "$file")

            if [[ "$file" == *test* ]]; then
              dest="src/test/java/$package_path"
            else
              dest="src/main/java/$package_path"
            fi

            mkdir -p "$dest"
            mv "$file" "$dest/$class_name"
            echo "‚úÖ Movido: $file -> $dest/$class_name"
          done

      - name: Ejecutar pruebas unitarias y validar compilaci√≥n
        run: |
          cd repositorio-base
          mvn clean test

      - name: Correcci√≥n de errores de compilaci√≥n (m√°x 3 intentos)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          cd repositorio-base
          intentos=0
          exito=0

          while [ $intentos -lt 3 ]; do
            echo "üîÅ Intento de compilaci√≥n #$((intentos+1))"
            if mvn compile; then
              echo "‚úÖ Build exitoso en el intento $((intentos+1))"
              exito=1
              break
            else
              echo "‚ùå Fall√≥ la compilaci√≥n. Capturando errores..."
              mvn compile > errores_build.txt 2>&1 || true

              echo "üß† Enviando errores y c√≥digo a GPT para correcci√≥n..."

              cat clases_generadas.java > entrada_correccion.txt
              echo -e "\n\n--- ERRORES DE COMPILACI√ìN ---\n" >> entrada_correccion.txt
              cat errores_build.txt >> entrada_correccion.txt
              echo -e "\n\n--- C√ìDIGO BASE DEL PROYECTO ---\n" >> entrada_correccion.txt
              cat entrada_gpt.txt >> entrada_correccion.txt

              jq -Rs --arg SYSTEM_MSG "Corrige los errores de compilaci√≥n bas√°ndote en los errores entregados. No inventes clases nuevas. Solo modifica lo necesario." '{
                model: "gpt-4",
                messages: [
                  { "role": "system", "content": $SYSTEM_MSG },
                  { "role": "user", "content": . }
                ],
                temperature: 0.2
              }' entrada_correccion.txt > payload_correccion.json

              curl -s https://api.openai.com/v1/chat/completions \
                -H "Authorization: Bearer $OPENAI_API_KEY" \
                -H "Content-Type: application/json" \
                -d @payload_correccion.json > respuesta_correccion.json

              jq -r '.choices[0].message.content // "‚ùå GPT no devolvi√≥ contenido v√°lido."' respuesta_correccion.json \
                | sed '/^```/d' \
                > clases_generadas.java

              echo "üîÑ C√≥digo corregido recibido. Regenerando archivos..."
              rm -f clase_*.java src/main/java/ai/generated/*.java src/test/java/ai/generated/*.java || true

              # Reutilizar paso de separaci√≥n
              csplit --quiet --prefix=clase_ --suffix-format=%02d.java clases_generadas.java "/^package /" {*}

              for file in clase_*.java; do
                if grep -q '@Test' "$file"; then
                  dest="src/test/java/ai/generated"
                else
                  dest="src/main/java/ai/generated"
                fi

                class_name=$(grep -oP 'public\s+(class|interface|enum)\s+\K\w+' "$file" | head -n 1)
                if [ -n "$class_name" ]; then
                  mv "$file" "$dest/${class_name}.java"
                else
                  echo "‚ö†Ô∏è Clase sin nombre en $file. Eliminando."
                  rm "$file"
                fi
              done
            fi
            intentos=$((intentos+1))
          done

          if [ "$exito" -ne 1 ]; then
            echo "üö´ El build sigue fallando tras 3 intentos. Abortando push."
            exit 1
          fi
  

      - name: Commit y push de la nueva funcionalidad (si todo compila)
        if: success()
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          cd repositorio-base
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git checkout -b feature/autogenerado-${{ github.run_id }}

          git add .
          echo "üìÑ Archivos listos para commitear:"
          git diff --cached --name-status || echo "‚ö†Ô∏è No hay cambios detectados"

          if git diff --cached --quiet; then
            echo "‚õî No hay cambios para commitear, se omite push"
            exit 0
          fi

          git commit -m "ü§ñ Funcionalidad generada desde historia de usuario"
          git remote set-url origin https://x-access-token:${GH_PAT}@github.com/${{ github.repository }}.git
          git push origin HEAD
