name: Generar funcionalidad desde historia de usuario

on:
  push:
    paths:
      - 'historias-usuario/**.yml'

jobs:
  generar_codigo:
    runs-on: ubuntu-latest

    steps:
      - name: Clonar repositorio actual
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          path: repositorio-base

      - name: Detectar historia de usuario modificada
        id: historia
        run: |
          cd repositorio-base
          git fetch --unshallow || true
          base_sha="${{ github.event.before }}"
          if ! git cat-file -e "$base_sha"^{commit} 2>/dev/null; then
            echo "‚ö†Ô∏è SHA base no v√°lido o sin historial, usando HEAD^"
            base_sha="HEAD^"
          fi
          echo "üîç Comparando con base: $base_sha"
          archivo=$(git diff --name-only "$base_sha" HEAD | grep '^historias-usuario/.*\.yml$' | head -n 1 || true)
          if [ -z "$archivo" ]; then
            echo "‚õî No se encontr√≥ ninguna historia de usuario modificada. Abortando."
            exit 1
          fi
          echo "ruta=$archivo" >> "$GITHUB_OUTPUT"

      - name: Leer contenido de historia de usuario
        run: |
          cd repositorio-base
          cat "${{ steps.historia.outputs.ruta }}" > entrada_gpt.txt

      - name: Instalar dependencias necesarias
        run: |
          sudo apt-get update
          sudo apt-get install -y jq unzip openjdk-17-jdk maven

      - name: Indexar y agregar contenido de clases Java existentes al prompt
        run: |
          cd repositorio-base

          echo "üìÅ Buscando clases Java..."
          find src/main/java -type f -name "*.java" > clases_existentes.txt

          if [ ! -s clases_existentes.txt ]; then
            echo "‚ùå No se encontraron archivos .java. Abortando."
            exit 1
          fi

          echo -e "\n\n--- HISTORIA DE USUARIO ---" > entrada_gpt.txt
          cat "${{ steps.historia.outputs.ruta }}" >> entrada_gpt.txt

          echo -e "\n\n--- C√ìDIGO EXISTENTE DEL PROYECTO ---" >> entrada_gpt.txt

          while read -r clase; do
            echo -e "\n\n// Archivo: $clase\n" >> entrada_gpt.txt

            # Validaci√≥n fuerte: si el archivo contiene '// Other methods...', aborta
            if grep -q '// Other methods' "$clase"; then
              echo "‚õî El archivo $clase contiene '// Other methods...'. Reempl√°zalo por el c√≥digo real antes de continuar."
              exit 1
            fi

            cat "$clase" >> entrada_gpt.txt
          done < clases_existentes.txt

          cat <<'EOF' >> entrada_gpt.txt

          --- AN√ÅLISIS DE CLASES EXISTENTES ---
          Genera una tabla Markdown como esta:

          | Clase Java | Package | Clasificaci√≥n | Motivo |
          |------------|---------|----------------|--------|
          | Employee | com.example.EmployeeCoreApi.model | REUTILIZABLE-AS-IS | Contiene atributo `gender` |
          | EmployeeServiceImpl | com.example.EmployeeCoreApi.service.impl | MODIFICABLE | Debe validar antes de borrar |
          | CannotDeleteEmployeeException | com.example.EmployeeCoreApi.exception | NUEVA | Requerida para lanzar excepci√≥n |
          | EmployeeServiceImplTest | com.example.EmployeeCoreApi.service.impl | NUEVA | Pruebas unitarias de validaci√≥n |

          --- INSTRUCCIONES DE MODIFICACI√ìN ---
          - No eliminar ni reemplazar l√≥gica existente.
          - Si se modifica un m√©todo, incluirlo completo con el nuevo c√≥digo y lo que ya ten√≠a.
          - Solo generar clases nuevas si est√°n indicadas como NUEVA.
          - Cada clase debe estar en su package correcto, seg√∫n lo indicado en la tabla.
          - NO repetir clases ya existentes si no cambian.
          - NO eliminar los m√©todos existentes a menos que sea necesario
          - NO reemplazar m√©todos u otro contenido de las clases existentes por comentarios entre l√≠neas

          --- C√ìDIGO A GENERAR ---
          Devuelve solo clases Java v√°lidas. Cada bloque debe comenzar con `package ...`.
          Incluye los tests JUnit5 en el mismo formato si aplica.
          EOF


      - name: Mostrar tabla de diagn√≥stico (si existe)
        run: |
          echo "üìã Tabla de clases seg√∫n GPT:"
          grep '|' repositorio-base/respuesta_gpt.json || echo "‚ö†Ô∏è GPT no gener√≥ tabla de diagn√≥stico"

      - name: Llamar a OpenAI para diagn√≥stico (solo an√°lisis y clasificaci√≥n)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          cd repositorio-base

          jq -Rs --arg SYSTEM_MSG "Eres un analizador experto de c√≥digo Java. Devuelve solo el an√°lisis de clases existentes y el plan de modificaci√≥n. No devuelvas c√≥digo a√∫n." '{
            model: "gpt-4",
            messages: [
              { "role": "system", "content": $SYSTEM_MSG },
              { "role": "user", "content": . }
            ],
            temperature: 0.2
          }' entrada_gpt.txt > payload_diagnostico.json

          curl -s https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_diagnostico.json > respuesta_gpt_diagnostico.json

          echo "üì® Respuesta de OpenAI:"
          cat respuesta_gpt_diagnostico.json

          jq -r '.choices[0].message.content // "‚ùå GPT no devolvi√≥ contenido v√°lido."' respuesta_gpt_diagnostico.json > diagnostico_gpt.txt

      - name: Mostrar an√°lisis GPT
        run: |
          echo "üìã Tabla de diagn√≥stico de clases:"
          cat repositorio-base/diagnostico_gpt.txt || echo "‚ö†Ô∏è No se pudo leer diagn√≥stico"

      - name: Preparar entrada para generaci√≥n de c√≥digo
        run: |
          cd repositorio-base

          echo "--- HISTORIA DE USUARIO ---" > entrada_final_gpt.txt
          cat "${{ steps.historia.outputs.ruta }}" >> entrada_final_gpt.txt

          echo -e "\n\n--- DIAGN√ìSTICO Y PLAN DE CLASES ---" >> entrada_final_gpt.txt
          cat diagnostico_gpt.txt >> entrada_final_gpt.txt

          cat <<'EOF' >> entrada_final_gpt.txt

          --- INSTRUCCIONES DE GENERACI√ìN DE C√ìDIGO ---
          - Modifica √∫nicamente las clases marcadas como MODIFICABLE.
          - Crea nuevas clases solo si est√°n indicadas como NUEVA.
          - No cambies de paquete ni nombre de clase.
          - Si modificas un m√©todo, incl√∫yelo completo con su l√≥gica anterior m√°s la nueva.
          - No omitas l√≥gica existente.
          - Cada clase debe comenzar con `package ...`.
          - Devuelve √∫nicamente clases y tests JUnit 5 v√°lidos.
          - No incluyas explicaciones ni comentarios adicionales.
          - Si una clase existente implementa una interfaz, o hereda de otra clase, debes mantener esa declaraci√≥n `implements o extends ...`.
          - No elimines implementaciones de interfaces ya declaradas.
          - La firma de las clases y m√©todos debe mantenerse sin cambio a menos que la nueva funcionalidad lo requiera

          EOF


      - name: Llamar a OpenAI para generaci√≥n de c√≥digo
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          cd repositorio-base

          # Guardamos el contenido del prompt como variable segura
          PROMPT=$(cat entrada_final_gpt.txt | jq -Rs .)

          # Creamos el JSON de payload
          cat <<EOF > payload_generacion.json
          {
            "model": "gpt-4",
            "messages": [
              {
                "role": "system",
                "content": "Eres un generador de c√≥digo Java experto en Spring Boot. Tu salida debe contener √∫nicamente c√≥digo fuente Java completamente v√°lido. Cada clase debe comenzar con 'package ...' y contener la declaraci√≥n completa de la clase (public class, interface o enum). No debes escribir ning√∫n texto explicativo, encabezado, numeraci√≥n, ni comentarios como '1.', '2.', 'Test Unitario:', etc. Si la clase ya existe en el repositorio, debes conservar su package original y todos sus m√©todos, incluso si no se modifican. No puedes inventar nuevos packages como 'com.example.demo'. Si una clase es nueva, debe estar marcada como NUEVA en el an√°lisis previo. No escribas ning√∫n contenido fuera de los bloques de c√≥digo. El resultado debe ser compilable sin errores ni contenido basura."
              },
              {
                "role": "user",
                "content": $PROMPT
              }
            ],
            "temperature": 0.3
          }
          EOF

          echo "üßæ Payload generado para OpenAI:"
          cat payload_generacion.json

          curl -s https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_generacion.json > respuesta_gpt.json

          echo "üì® Respuesta de OpenAI:"
          cat respuesta_gpt.json

          jq -r '.choices[0].message.content // "‚ùå GPT no devolvi√≥ contenido v√°lido."' respuesta_gpt.json \
          | sed '/^```/d' \
          > clases_generadas.java

      - name: Limpiar y separar clases generadas
        run: |
          cd repositorio-base
      
          # === LIMPIEZA DE BLOQUE GPT ===
          echo "üßπ Limpiando residuos de formato GPT..."
          sed -i '/^---/d' clases_generadas.java
          sed -i '/^```/d' clases_generadas.java
          sed -i '/^\/\/ Clase de prueba:/d' clases_generadas.java
          sed -i '/^\/\/ Clase modificada:/d' clases_generadas.java
          sed -i '/^\/\/ Resto de los m√©todos existentes\.\.\./d' clases_generadas.java
          sed -i '/^# .*$/d' clases_generadas.java
          sed -i '/^--- CLASE MODIFICADA ---/d' clases_generadas.java
          sed -i '${/^$/d;}' clases_generadas.java
          # üîç Eliminar encabezados tipo markdown que confunden la separaci√≥n de clases
          sed -i '/^[0-9]\+\.\s\+Clase/d' clases_generadas.java
          sed -i '/^[0-9]\+\.\s\+Pruebas/d' clases_generadas.java
          sed -i '/^.*Clase.*nueva.*$/d' clases_generadas.java
          sed -i '/^.*Pruebas.*$/d' clases_generadas.java

      
          # === ELIMINAR L√çNEAS ANTES DEL PRIMER package ===
          sed -i '1,/^package /{/^package /!d}' clases_generadas.java
      
          # === SEPARACI√ìN DE CLASES ===
          echo "üìÇ Separando clases en archivos individuales..."
          mkdir -p src/main/java/ai/generated
          mkdir -p src/test/java/ai/generated
          csplit --quiet --prefix=clase_ --suffix-format=%02d.java clases_generadas.java "/^package /" {*}
      
          echo "üìÇ Procesando archivos clase_*.java..."

          i=1
          for file in clase_*.java; do
            echo "üîç Analizando archivo: $file"

            # Validar que el archivo contiene declaraci√≥n de paquete v√°lida
            if ! grep -qE '^\s*package\s+[a-zA-Z0-9_.]+;' "$file"; then
              echo "‚ö†Ô∏è Archivo $file no contiene declaraci√≥n de paquete v√°lida. Eliminando."
              rm "$file"
              continue
            fi

            # Validar que contiene una clase, interfaz o enum
            if ! grep -qE '\b(class|interface|enum)\b' "$file"; then
              echo "‚ö†Ô∏è Archivo $file no contiene clase, interfaz ni enum. Eliminando."
              rm "$file"
              continue
            fi

            # Obtener nombre de la clase, interfaz o enum
            class_name=$(grep -oP 'public\s+(class|interface|enum)\s+\K\w+' "$file" | head -n 1)

            # Validar que se haya encontrado un nombre de clase
            if [ -z "$class_name" ]; then
              echo "‚ö†Ô∏è No se pudo determinar el nombre de clase en $file. Eliminando."
              rm "$file"
              continue
            fi

            # Determinar si es test
            if grep -q '@Test' "$file"; then
              dest="src/test/java/ai/generated"
              echo "‚úÖ Clasificado como TEST -> $dest/${class_name}.java"
            else
              dest="src/main/java/ai/generated"
              echo "‚úÖ Clasificado como CLASE -> $dest/${class_name}.java"
            fi

            mv "$file" "$dest/${class_name}.java"
            i=$((i+1))
          done


      - name: Reemplazar clases generadas en ubicaci√≥n original
        run: |
          cd repositorio-base

          echo "üì¶ Detectando package y ubicaci√≥n de cada clase..."

          for file in src/main/java/ai/generated/*.java src/test/java/ai/generated/*.java; do
            [ -e "$file" ] || continue

            package_line=$(grep '^package ' "$file" | head -n 1)
            package_path=$(echo "$package_line" | sed -E 's/package ([a-zA-Z0-9_.]+);/\1/' | tr '.' '/')
            class_name=$(basename "$file")

            if [[ "$file" == *test* ]]; then
              dest="src/test/java/$package_path"
            else
              dest="src/main/java/$package_path"
            fi

            mkdir -p "$dest"
            mv "$file" "$dest/$class_name"
            echo "‚úÖ Movido: $file -> $dest/$class_name"
          done

          - name: Correcci√≥n de errores de compilaci√≥n (m√°x 3 intentos)
          env:
            OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          run: |
            cd repositorio-base
        
            intentos=0
            exito=0
        
            while [ $intentos -lt 3 ]; do
              echo "üîÅ Intento de compilaci√≥n #$((intentos+1))"
              if mvn compile; then
                echo "‚úÖ Compilaci√≥n exitosa"
                exito=1
                break
              fi
        
              echo "‚ùå Fall√≥ la compilaci√≥n. Capturando errores..."
              mvn compile > error_build.log 2>&1 || true
        
              echo "üß† Preparando an√°lisis de errores..."
              {
                echo "--- LOG DE COMPILACI√ìN FALLIDA ---"
                cat error_build.log
                echo
                echo "--- INSTRUCCIONES ---"
                echo "Eres un experto compilador de Java. Analiza los errores mostrados y entrega solo un plan de correcci√≥n breve y estructurado, indicando los archivos involucrados, los problemas y qu√© se debe corregir. No devuelvas c√≥digo, solo la lista clara de correcciones."
              } > prompt_diag.txt
        
              DIAG_PROMPT=$(jq -Rs . < prompt_diag.txt)
        
              echo "üì§ Enviando an√°lisis a GPT..."
              echo "{\"model\":\"gpt-4\",\"messages\":[{\"role\":\"system\",\"content\":\"Eres un experto en compilaci√≥n de Java. Devuelve solo un plan de correcci√≥n para los errores mostrados.\"},{\"role\":\"user\",\"content\":$DIAG_PROMPT}],\"temperature\":0.2}" > payload_diagnostico_errores.json
        
              curl -s https://api.openai.com/v1/chat/completions \
                -H "Authorization: Bearer $OPENAI_API_KEY" \
                -H "Content-Type: application/json" \
                -d @payload_diagnostico_errores.json > respuesta_diagnostico.json
        
              PLAN_CORRECCION=$(jq -r '.choices[0].message.content' respuesta_diagnostico.json)
              echo "üìã Plan de correcci√≥n recibido:"
              echo "$PLAN_CORRECCION"
        
              echo "üß† Preparando prompt de c√≥digo corregido..."
              {
                echo "--- PLAN DE CORRECCI√ìN ---"
                echo "$PLAN_CORRECCION"
                echo
                echo "--- C√ìDIGO ACTUAL ---"
                cat clases_generadas.java
                echo
                echo "--- INSTRUCCIONES ---"
                echo "Corrige el c√≥digo entregado seg√∫n el plan anterior. Devuelve solo clases Java v√°lidas. Cada clase debe comenzar con 'package ...'. No incluyas explicaciones ni encabezados. No utilices backticks (\`)."
              } > prompt_cod.txt
        
              CODIGO_PROMPT=$(jq -Rs . < prompt_cod.txt)
        
              echo "{\"model\":\"gpt-4\",\"messages\":[{\"role\":\"system\",\"content\":\"Eres un generador de c√≥digo Java. Devuelve solo clases completas y v√°lidas seg√∫n el plan de correcci√≥n.\"},{\"role\":\"user\",\"content\":$CODIGO_PROMPT}],\"temperature\":0.3}" > payload_codigo_corregido.json
        
              echo "üì§ Enviando c√≥digo a GPT para correcci√≥n..."
              curl -s https://api.openai.com/v1/chat/completions \
                -H "Authorization: Bearer $OPENAI_API_KEY" \
                -H "Content-Type: application/json" \
                -d @payload_codigo_corregido.json > respuesta_codigo.json
        
              jq -r '.choices[0].message.content // "‚ùå Sin contenido v√°lido."' respuesta_codigo.json \
                | sed '/^```/d' > clases_generadas.java
        
              echo "üîÑ C√≥digo corregido recibido. Regenerando archivos..."
              rm -f clase_*.java
              sed -i 's/`//g' clases_generadas.java
              sed -i '1,/^package /{/^package /!d}' clases_generadas.java
        
              csplit --quiet --prefix=clase_ --suffix-format=%02d.java clases_generadas.java "/^package /" {*}
        
              mkdir -p src/main/java/ai/generated
              mkdir -p src/test/java/ai/generated
        
              for file in clase_*.java; do
                if ! grep -qE 'package\s+[a-zA-Z0-9_.]+;' "$file"; then rm "$file"; continue; fi
                if ! grep -qE '\b(class|interface|enum)\b' "$file"; then rm "$file"; continue; fi
                class_name=$(grep -oP 'public\s+(class|interface|enum)\s+\K\w+' "$file" | head -n 1)
                [ -z "$class_name" ] && rm "$file" && continue
                if grep -q '@Test' "$file"; then
                  mv "$file" "src/test/java/ai/generated/${class_name}.java"
                else
                  mv "$file" "src/main/java/ai/generated/${class_name}.java"
                fi
              done
        
              intentos=$((intentos+1))
            done
        
            if [ $exito -eq 0 ]; then
              echo "‚ùå Se alcanz√≥ el m√°ximo de intentos de correcci√≥n sin √©xito"
              exit 1
            fi
        
      - name: Commit y push de la nueva funcionalidad (si todo compila)
        if: success()
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          cd repositorio-base
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git checkout -b feature/autogenerado-${{ github.run_id }}

          git add .
          echo "üìÑ Archivos listos para commitear:"
          git diff --cached --name-status || echo "‚ö†Ô∏è No hay cambios detectados"

          if git diff --cached --quiet; then
            echo "‚õî No hay cambios para commitear, se omite push"
            exit 0
          fi

          git commit -m "ü§ñ Funcionalidad generada desde historia de usuario"
          git remote set-url origin https://x-access-token:${GH_PAT}@github.com/${{ github.repository }}.git
          git push origin HEAD
